{"componentChunkName":"component---src-templates-blog-post-js","path":"/lambda-calculus/","result":{"data":{"site":{"siteMetadata":{"title":"Proven Axiom"}},"markdownRemark":{"id":"0f2ce05d-1a8b-5e55-beb4-949cf83f3260","excerpt":"My Recurse Center batch ended a couple weeks ago, and I wanted to write a report on the project which took the biggest part of my time: reading Types and…","html":"<p>My <a href=\"https://www.recurse.com\">Recurse Center</a> batch ended a couple weeks ago, and I wanted to write a report on the project which took the biggest part of my time: reading <a href=\"https://www.goodreads.com/book/show/112252.Types_and_Programming_Languages\">Types and programming Languages</a>, and building in Haskell the various flavours of lambda calculi described in the book.</p>\n<p>I actually ended up only going through the most basic lambda calculus variant (called “untyped” lambda calculus), and building a CLI REPL for it. But I made a few additions, including:</p>\n<ul>\n<li>The possibility to assign variables.</li>\n<li>A full beta evaluation mode (while the book only focuses on a call by value strategy).</li>\n<li>A small webapp embedding the REPL.</li>\n<li>Inside this webapp, a gamified tutorial with some walkthrough / exercises to learn about lambda calculus. This is far from being perfect, but I encourage you to <a href=\"https://vincent-prz.github.io/lambda-calculus-repl/\">try it</a> if you feel curious!</li>\n</ul>\n<p><a href=\"https://github.com/vincent-prz/tapl\">Here</a> is the source code of the project. In the next sections I will go through some interesting challenges I encountered.</p>\n<h1>Challenge 1: Left recursion</h1>\n<p>Preliminary note: this section might not make sense if you don’t have knowledge about parsing; in this case you can head to the next section.</p>\n<p>The (untyped) lambda calculus is conceptually simple, but as often with programming, the devil is in the details. The first notable challenge I faced was related to parsing (which, by the way, is not covered by TAPL).</p>\n<p>I used the <a href=\"https://en.wikipedia.org/wiki/Recursive_descent_parser\">recursive descent</a> technique, with the help of the <a href=\"https://hackage.haskell.org/package/parsec\">parsec</a> library. Unfortunately, this technique doesn’t deal very well with <a href=\"https://en.wikipedia.org/wiki/Left_recursion\">left recursion</a>. Before explaining what left recursion is, let’s look at the syntax of the lambda calculus:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">term -&gt; &lt;abstraction&gt; | &lt;application&gt; | &lt;var&gt;\nabstraction -&gt; λ&lt;var&gt;.&lt;expr&gt;\napplication -&gt; &lt;term&gt; &lt;term&gt;\nvar -&gt; string</code></pre></div>\n<p>In English, this means: </p>\n<ul>\n<li>A term is either an abstraction, application, or variable. </li>\n<li>An abstraction (or function definition) is a lambda symbol followed by a variable, followed by a dot, followed by a term.</li>\n<li>A function application is two terms separated by a space.</li>\n<li>A variable is a string.</li>\n</ul>\n<p>As per Wikipedia:</p>\n<blockquote>\n<p>a nonterminal is left-recursive if the leftmost symbol in one of its productions is itself (in the case of direct left recursion) or can be made itself by some sequence of substitutions (in the case of indirect left recursion). </p>\n</blockquote>\n<p>It turns out that the <code class=\"language-text\">application</code> rule (or nonterminal) is left recursive, because if in its right side we substitute the left <code class=\"language-text\">term</code> by <code class=\"language-text\">application</code> (we know we can because we know from the first rule that a <code class=\"language-text\">term</code> can be an <code class=\"language-text\">application</code>) we get this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">application -&gt; &lt;application&gt; &lt;term&gt;</code></pre></div>\n<p>This fits the indirect case of left recursion, which, as said above, cause problems for the parsing technique I used, recursive descent. Namely, it creates an infinite recursion.</p>\n<p>I spent quite some time on this issue, but I eventually solved it by taking inspiration from the <a href=\"http://www.craftinginterpreters.com/parsing-expressions.html\">Crafting Interpreters book</a>.</p>\n<p>Writing the parser manually was very instructive, but I think next time I’ll need to parse something, I’ll probably use <a href=\"https://en.m.wikipedia.org/wiki/Yacc\">yacc</a> or <a href=\"https://www.haskell.org/happy/\">Happy</a>, the <code class=\"language-text\">yacc</code> equivalent for Haskell.</p>\n<h1>Challenge 2: bring Haskell to the browser</h1>\n<p>I wanted this project to be easily accessible, without needing to download the code and the Haskell ecosystem, hence I decided to make a web version of it.</p>\n<p>More precisely, I made a frontend only app (or SPA) by compiling my Haskell code to Javascript with <a href=\"https://github.com/ghcjs/ghcjs\">GHCJS</a>. Here are a few things worth mentioning:</p>\n<ul>\n<li>I had to use the <a href=\"https://nixos.org/nix/\">Nix</a> package manager, since Stack (the haskell package manager I was using) dropped support for it.</li>\n<li>To develop the app, I started with the <a href=\"https://github.com/reflex-frp/reflex\">Reflex</a> library, but got confused by its API, hence I switched to <a href=\"https://github.com/dmjio/miso\">Miso</a>, which has an API very similar to <a href=\"https://elm-lang.org/\">Elm</a>, or React / Redux. While <code class=\"language-text\">Reflex</code> probably shines with complex UI needs, I believe the much smoother learning curve of <code class=\"language-text\">Miso</code> was more adapted to my needs.</li>\n</ul>\n<p>All in all, I reckon that this could have been easier with better documentation, but at the end of the day it feels quite good to be able to target the browser with Haskell.</p>\n<p>To go even further, there is <a href=\"https://github.com/obsidiansystems/obelisk\">Obelisk</a>, which is a platform aiming to target not only the browser, but also desktop and mobile applications, with Haskell.</p>\n<h1>Other challenges</h1>\n<p>Here is a quick list of obstacles which were more or less challenging:</p>\n<ul>\n<li>Prevent <a href=\"https://en.wikipedia.org/wiki/Lambda_calculus#Capture-avoiding_substitutions\">variable capture</a>: this turned out to be quite tricky.</li>\n<li>Implementing the semantics with <a href=\"https://en.wikipedia.org/wiki/Operational_semantics\">operational semantics</a>.</li>\n<li>Add some basic CSS to the webapp: I used <a href=\"https://bulma.io/\">Bulma</a>.</li>\n<li>Get familiar with Haskell tooling (Cabal, Stack).</li>\n<li>Implement the tutorial / game mechanics.</li>\n</ul>\n<h1>What ‘s next ?</h1>\n<p>I probably won’t finish the book (at least not in the short term). But I would like, at the very least, to implement the simply typed flavour of lambda calculus, in order to to see what it’s like to implement a type checker.</p>","frontmatter":{"title":"Creating a lambda calculus interpreter - report","date":"December 30, 2019","description":"Creating a lambda calculus interpreter - report"}},"previous":{"fields":{"slug":"/functor-derivation/"},"frontmatter":{"title":"Understanding Haskell functor derivation with Category Theory"}},"next":{"fields":{"slug":"/cs-books-2020/"},"frontmatter":{"title":"CS books I read in 2020"}}},"pageContext":{"id":"0f2ce05d-1a8b-5e55-beb4-949cf83f3260","previousPostId":"9a3fb52a-addb-5b64-ab97-b3cf92c3301d","nextPostId":"db260eda-6727-5770-ac3a-b55c6b815ea7"}},"staticQueryHashes":["2841359383","3257411868"]}