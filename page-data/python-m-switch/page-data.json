{"componentChunkName":"component---src-templates-blog-post-js","path":"/python-m-switch/","result":{"data":{"site":{"siteMetadata":{"title":"Proven Axiom"}},"markdownRemark":{"id":"d7069f95-6ca5-5cd2-ae68-efb5249f7c9a","excerpt":"This post will be very short, and aside from explaining what is the -m switch and how it works, it will also serve 2 secondary purposes: putting me back in the…","html":"<p>This post will be very short, and aside from explaining what is the -m switch and how it works, it will also serve 2 secondary purposes:</p>\n<ul>\n<li>putting me back in the habit of writing (I haven’t been writing for more than one year)</li>\n<li>tightening my own grasp of the -m switch : Python ‘s import system has always been a bit confusing to me.</li>\n</ul>\n<h2>What is it ?</h2>\n<p>The -m (for mod) switch, is a switch you can give to the python interpreter; if you type <code class=\"language-text\">python --help</code>, you ‘ll see the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-m mod : run library module as a script (terminates option list)</code></pre></div>\n<p>It means that if you have a Python project with the following file hierarchy:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">├── foo\n│   └── foo.py</code></pre></div>\n<p>You can execute the module contained in the <code class=\"language-text\">foo.py</code>  as a script with the following command: <code class=\"language-text\">python -m foo.foo</code>. Notice the syntax of the argument for the -m switch: it’s a dotted syntax, akin to the syntax for importing modules in Python files. In particular, this syntax <code class=\"language-text\">python -m foo/foo.py</code> wouldn’t be valid.</p>\n<p>The above example was rather contrived, let’s see a more interesting example, which will involve the notion of module search path. </p>\n<h2>Example</h2>\n<p>Let’s consider the following project structure:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">├── bar\n│   ├── bar.py\n├── foo\n│   ├── foo.py</code></pre></div>\n<p>And let’s assume the module <code class=\"language-text\">bar.bar</code> needs to import something from the <code class=\"language-text\">foo.foo</code> module:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># bar/bar.py\nfrom foo.foo import foo\n\n\ndef bar():\n    foo()\n\n\nif __name__ == &#39;main&#39;:\n    print(&#39;bar module called as script&#39;)</code></pre></div>\n<p>Now, let’s say we want to execute the <code class=\"language-text\">bar.bar</code> module as a script, from the project directory. One could try to do:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">python bar/bar.py`</code></pre></div>\n<p>But then they would have the following error:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ModuleNotFoundError: No module named &#39;foo&#39;</code></pre></div>\n<p>To understand this, we need to introduce the notion of <em>module search path</em>. Basically, everytime Python tries to perform an <code class=\"language-text\">import</code> statement, it is looking for the corresponding module / package in a list of directories, which is the module search path.</p>\n<p>As per the <a href=\"https://docs.python.org/3/tutorial/modules.html#the-module-search-path\">Python documentation</a>, the module search path is initialized from these locations:</p>\n<ul>\n<li>The directory containing the input script (or the current directory when no file is specified).</li>\n<li>PYTHONPATH (a list of directory names, with the same syntax as the shell variable PATH).</li>\n<li>The installation-dependent default.</li>\n</ul>\n<p>Back to our example: the directory containing the input script is <code class=\"language-text\">bar</code>, from which the <code class=\"language-text\">foo</code> folder is not reachable, hence the <code class=\"language-text\">ModuleNotFoundError</code>. So how do we manage to execute the <code class=\"language-text\">bar.bar</code> module as a script ? We can use the <code class=\"language-text\">-m</code> switch!</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">python -m bar.bar</code></pre></div>\n<p>This way i’ll work as expected and display the following output:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">bar module called as script</code></pre></div>\n<p>It works because in this case Python considered the folder from which we ran the command to be part of the module search path; indeed, let’s look back at the first clause of the module search path initialization: “The directory containing the input script (or the current directory when no file is specified)” - we didn’t specify any file (what we did specify is a module), hence Python took the current directory as part of the module search path, and hence was able to locate the foo/foo.py module.</p>\n<p>That’s the end of my explanation - I’ll tackle Python’s relative imports (another nemesis of mine) some day if I feel brave.</p>","frontmatter":{"title":"The Python -m switch","date":"March 14, 2021","description":"Explaining Python's -m switch"}},"previous":{"fields":{"slug":"/lambda-calculus/"},"frontmatter":{"title":"Creating a lambda calculus interpreter - report"}},"next":{"fields":{"slug":"/nand-2-tetris-review/"},"frontmatter":{"title":"Nand 2 Tetris: review"}}},"pageContext":{"id":"d7069f95-6ca5-5cd2-ae68-efb5249f7c9a","previousPostId":"0f2ce05d-1a8b-5e55-beb4-949cf83f3260","nextPostId":"38f1bed9-f537-5bf3-9b33-ffae354118d3"}},"staticQueryHashes":["2841359383","3257411868"]}