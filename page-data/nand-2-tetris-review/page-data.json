{"componentChunkName":"component---src-templates-blog-post-js","path":"/nand-2-tetris-review/","result":{"data":{"site":{"siteMetadata":{"title":"Proven Axiom"}},"markdownRemark":{"id":"38f1bed9-f537-5bf3-9b33-ffae354118d3","excerpt":"Nand 2 Tetris, and the companion book The elements of computing systems, form a set of projects from which we build a computer, starting with the logical gate…","html":"<p><a href=\"https://www.nand2tetris.org/\">Nand 2 Tetris</a>, and the companion book <a href=\"https://www.goodreads.com/book/show/910789.The_Elements_of_Computing_Systems\">The elements of computing systems</a>, form a set of projects from which we build a computer, starting with the logical gate NAND. After completing the last project, we have a computer sufficiently powerful to run a Tetris game, hence the name. </p>\n<p>In the process, we learn about a wide variety of computer science topics, such as boolean logic, hardware, computer architecture, compilers, operating systems …</p>\n<p>I completed the book over the course of last year, and was helpful in keeping me busy during those COVID times. I have been meaning to write about it for a while, and I’m finally breaking through the walls of procrastination with this article.</p>\n<h2>Why you should <em>do</em> this book</h2>\n<p>The book / course is divided in 12 chapters, starting from the lowest level of abstraction (the NAND Gate) to highest (The Operating system). Each chapter contains a background section, and a project to implement.</p>\n<p>While the first five chapters of the book are focused on building the hardware components, using a hardware description language (HDL) and a hardware simulator provided by the Nand 2 Tetris website, the remaining chapters cover the software components (OS, compiler, virtual machine ..) and can be implemented in any programming language. </p>\n<p>Image</p>\n<p>Hence this not a book that should be passively read, but actively makes the reader build a component helping them climb the abstraction ladder from the NAND logical gate to a full fledged computer. To this day this is the funniest CS / programming book I have ever read, the completion of each chapter yielded a great feeling of achievement.</p>\n<h2>My main take aways</h2>\n<p>It’s been a while since I completed the book, and there would be countless take aways to retain from it, but on he top of my head here are the things I want to highlight.</p>\n<h3>Building abstractions</h3>\n<p>The introduction provides a great definition of an <em>abstraction</em>:</p>\n<blockquote>\n<p>the statement of “what an entity does”, ignoring the details of “how it does it”.</p>\n</blockquote>\n<p>Any programmers knows how important is this idea, in order to make modular code and prevent the codebase’s complexity from skyrocketing.</p>\n<p>The structure of the book itself illustrates this idea, indeed each chapter’s project is doable independently, using the building blocks (abstractions) implemented in the chapters below.</p>\n<p>Fun fact: one friend recently brought to my attention that the name of the book was certainly chosen after <a href=\"https://en.wikipedia.org/wiki/Euclid%27s_Elements\">Euclide’s Elements</a>, considered to be the most influential mathematical textbook ever, and in which Euclide starts with axiom and deductively builds more and more complex mathematical abstractions.</p>\n<h3>the von Neumann architecture and the stored program concept</h3>\n<p>In chapter 5, the last hardware chapter, we assemble the components from previous chapters to build a general purpose computer, using the <a href=\"https://en.wikipedia.org/wiki/Von_Neumann_architecture\">von Neumann architecture</a>.</p>\n<p>The von Neumann achitecture is introduced along with the <a href=\"https://en.wikipedia.org/wiki/Stored-program_computer\">stored program</a> concept. Simply put, the idea consists in putting a program’s code into the computer memory, just like data, rather than embedding the program in hardware (which was the case for mechanical computers before 1930).</p>\n<p>This simple idea is used by most modern computers, and allows them, with a finite repertoire of instructions, to execute arbitrarly complex programs, by changing the program stored in memory (known as software). Hence in essence it is what makes our modern computers the versatile tools we know.</p>\n<h3>2 tiers compiler architecture</h3>\n<p>The book makes us build a compiler for language named Jack. Rather than making the compilation a process which translates source code to binary code in a single step, the compilation is broken into two steps: one step from the source language to an intermediary language, called virtual machine (VM) code, and a second step from the VM code to binary.</p>\n<p>This has the advantage of decoupling the parsing of the source language (compiler frontend) from the generation of the target machine code (compiler backend).</p>\n<p>This technique is used by Java (and its JVM) and has enabled the spread of many languages for the JVM platform, allowing their creators to focus only on the VM code generation, regardless of the target machine code.</p>\n<h2>Conclusion</h2>\n<p>I enjoyed this book so much that I might redo the projects a second time - like I would redo a great video game.</p>","frontmatter":{"title":"Nand 2 Tetris: review","date":"June 19, 2021","description":"Giving my impressions on this amazing book."}},"previous":{"fields":{"slug":"/python-m-switch/"},"frontmatter":{"title":"The Python -m switch"}},"next":null},"pageContext":{"id":"38f1bed9-f537-5bf3-9b33-ffae354118d3","previousPostId":"d7069f95-6ca5-5cd2-ae68-efb5249f7c9a","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"]}