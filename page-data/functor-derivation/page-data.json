{"componentChunkName":"component---src-templates-blog-post-js","path":"/functor-derivation/","result":{"data":{"site":{"siteMetadata":{"title":"Proven Axiom"}},"markdownRemark":{"id":"9a3fb52a-addb-5b64-ab97-b3cf92c3301d","excerpt":"Recently I have been reading the Category for programmers book from Bartosz Milewski, and one thing that amazes me is the realization that the implementation of…","html":"<p>Recently I have been reading the <a href=\"https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/\">Category for programmers</a> book from Bartosz Milewski, and one thing that amazes me is the realization that the implementation of well known functors such as <code class=\"language-text\">Maybe</code> or <code class=\"language-text\">List</code> could in fact be mechanically derived from some primitive functors.</p>\n<p>However, I was struggling to understand the demonstration of this result (see the “Functorial Algebraic data Types” section <a href=\"https://bartoszmilewski.com/2015/02/03/functoriality/\">here</a>, or section 8.3 in the pdf). So I decided to try to convince myself with code.</p>\n<h1>TL; DR</h1>\n<p>If you want to get the result directly, here it is: you can automatically derive <code class=\"language-text\">Functor</code> instances from algebraic data types (ie sum and / or products of types), much like you would derive <code class=\"language-text\">Eq</code> or <code class=\"language-text\">Show</code> instances. To that end, you can use the <a href=\"https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-DeriveFunctor\">DerivFunctor extension</a>.</p>\n<p>For instance, you could redefine the Maybe type and automagically  derive its <code class=\"language-text\">Functor</code> instance this way.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{-# LANGUAGE DeriveFunctor #-}\n\n-- first hide the Maybe from the standard Prelude\nimport Prelude hiding (Maybe(..))\n\ndata Maybe a = Nothing | Just a\n  deriving Functor</code></pre></div>\n<h1>Functoriality of algebraic data types, examples</h1>\n<p>The underlying property which permits this mechanical derivation can be stated this way: a parameterized algebraic data type (ADT) <code class=\"language-text\">T</code> is functorial in any of its type parameters.</p>\n<p>For example, according to this result, the ADT <code class=\"language-text\">Maybe a</code> is functorial in <code class=\"language-text\">a</code>. The following ADT:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">newtype Pair a b =\n  Pair (a, b)</code></pre></div>\n<p>is functorial in <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code>. Indeed, the following <code class=\"language-text\">Functor</code> instance accounts for the functoriality in <code class=\"language-text\">b</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">instance Functor (Pair a) where\n  fmap f (Pair (a, b)) = Pair (a, f b)</code></pre></div>\n<p>Haskell doesn’t allow us to declare a <code class=\"language-text\">Functor</code> of <code class=\"language-text\">Pair</code> in <code class=\"language-text\">a</code>, but we can get its equivalent by declaring another type:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">newtype ReversedPair b a =\n  ReversedPair (a, b)\n\ninstance Functor (ReversedPair b) where\n  fmap f (ReversedPair (a, b)) = ReversedPair (f a, b)</code></pre></div>\n<p><code class=\"language-text\">ReversedPair</code> is the same as <code class=\"language-text\">Pair</code>, but with parameterized types reversed. This accounts for the functoriality of <code class=\"language-text\">Pair</code> in <code class=\"language-text\">a</code>.</p>\n<h1>Functoriality of algebraic data types: refinement</h1>\n<p>The result stated in the previous section can actually be refined. Indeed, not only do we know that a parameterized ADT is functorial in any of its parameterized types, but we also know how to build the corresponding functors.</p>\n<p>Namely, those functors can mechanically be derived from the following things:</p>\n<ul>\n<li>the <code class=\"language-text\">Functor</code> instance for <code class=\"language-text\">Const ()</code></li>\n<li>the <code class=\"language-text\">Functor</code> instance for <code class=\"language-text\">Identity</code></li>\n<li>The <code class=\"language-text\">Bifunctor</code> instance for <code class=\"language-text\">Either</code></li>\n<li>The <code class=\"language-text\">Bifunctor</code> instance for <code class=\"language-text\">(,)</code></li>\n</ul>\n<p>How do we prove that ? The proof can be decomposed like this:</p>\n<ul>\n<li>(Fact 1): we know from, as Bartosz Milewski is saying in the paragraph we are looking at, that any algebraic data type is isomorphic to a combination of sum and products of <code class=\"language-text\">Const ()</code> and <code class=\"language-text\">Identity</code>. So <code class=\"language-text\">Const ()</code> and <code class=\"language-text\">Indentity</code> can be seen as basic building blocks for ADT. Moreover, we know that <code class=\"language-text\">sum</code> and <code class=\"language-text\">product</code> can be be represented as <code class=\"language-text\">Either</code>s and tuples respectively (ie via the <code class=\"language-text\">(,)</code> operator).</li>\n<li>(Fact 2): a finite sum and / or product of basic ADTs is functorial. This result can be obtained by induction, the base case being <code class=\"language-text\">Const ()</code> and <code class=\"language-text\">Identity</code>, and the induction case being the sum or product of a functorial ADT with <code class=\"language-text\">Const ()</code> or <code class=\"language-text\">Identity</code>.</li>\n<li>(Fact 3): We can deduce from Fact 1 and fact 2 that any ADT is functorial, with the added bonus that we know how to mechanically build the corresponding functors.</li>\n</ul>\n<p>Fact 1 being known, let’s try to get an intuition of why Fact 2 Fact 3 are true.</p>\n<h1>“Proof” with code (Part 1)</h1>\n<p>Recall that Fact 2 is obtained by induction. The base case is trivial, since both basic ADTs are notoriously functorial.</p>\n<p>Let’s move on to the induction case. It can be stated as follows: let T be a functorial ADT; then <code class=\"language-text\">T+Const()</code>, <code class=\"language-text\">T*Const ()</code>, <code class=\"language-text\">T+Identity</code> and <code class=\"language-text\">T*Identity</code> are functorial.</p>\n<p>To simplify things, let’s try to convince ourselves of this induction with a sum or product of two basic ADTs (ie <code class=\"language-text\">Const ()</code> or <code class=\"language-text\">Identity</code>).</p>\n<p>Such an ADT can be represented by the following type:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">newtype BiComp bf fu gu a b =\n  BiComp (bf (fu a) (gu b))</code></pre></div>\n<p>Where <code class=\"language-text\">bf</code> represents the sum or the product of two basics ADTS <code class=\"language-text\">fu</code> and <code class=\"language-text\">gu</code>; <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code> are the parameters of the ADT.</p>\n<p>So proving Fact 2 amounts to prove that BiComp is functorial in <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code>. Let’s review our assumptions:</p>\n<ul>\n<li><code class=\"language-text\">fu</code> is <code class=\"language-text\">Const ()</code> or <code class=\"language-text\">Identity</code>. In particular, it is functorial.</li>\n<li><code class=\"language-text\">gu</code> is <code class=\"language-text\">Const ()</code> or <code class=\"language-text\">Identity</code>. In particular, it is functorial.</li>\n<li><code class=\"language-text\">bf</code> is <code class=\"language-text\">Either</code> (sum) or <code class=\"language-text\">(,)</code> (product). In particular, it is bifunctorial.</li>\n</ul>\n<p>Using these assumptions, we can deduce that <code class=\"language-text\">BiComp</code> is bifunctorial; indeed, we can declare its <code class=\"language-text\">Bifunctor</code> instance like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">instance (Bifunctor bf, Functor fu, Functor gu) =&gt;\n         Bifunctor (BiComp bf fu gu) where\n  bimap f g (BiComp x) = BiComp (bimap (fmap f) (fmap g) x)</code></pre></div>\n<p>To paraphrase Bartosz Milewski, <code class=\"language-text\">bimap</code> breaks through the outer <code class=\"language-text\">bf</code> layer, while the two <code class=\"language-text\">fmap</code>s dig under <code class=\"language-text\">fu</code> and <code class=\"language-text\">gu</code> respectively. So <code class=\"language-text\">Bicomp bf fu gu</code> is bifunctorial, in particular it is functorial in <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code>. This gives us an intuition of Fact 2.</p>\n<h1>“Proof” with code (Part 2)</h1>\n<p>Let’s now consider Fact 3. Again, to simplify let us consider an ADT with two type parameters, such as <code class=\"language-text\">Pair a b</code> from above. The goal here is to prove that <code class=\"language-text\">Pair a b</code> is functorial in <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code>.</p>\n<p>We know from Fact 1 that such an ADT is isomorphic to a sum or product of <code class=\"language-text\">Const ()</code> or <code class=\"language-text\">Identity</code>. More precisely, <code class=\"language-text\">Pair a b</code> is isomorphic to the following type:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type Pair&#39; a b = BiComp (,) Identity Identity a b</code></pre></div>\n<p>Indeed, this ismorhism can be expressed through the following two functions:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">isoPair&#39; :: Pair a b -&gt; Pair&#39; a b\nisoPair&#39; (Pair (a, b)) = BiComp (Identity a, Identity b)\n\nisoPair :: Pair&#39; a b -&gt; Pair a b\nisoPair (BiComp (Identity a, Identity b)) = Pair (a, b)</code></pre></div>\n<p>From this, we can recover the functoriality of <code class=\"language-text\">Pair</code> in <code class=\"language-text\">b</code> like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">instance Functor (Pair a) where\n  fmap f = isoPair . second f . isoPair&#39;</code></pre></div>\n<p>Where <a href=\"https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bifunctor.html#v:second\">second</a> comes from the <code class=\"language-text\">Bifunctor</code> typeclass. The functoriality in <code class=\"language-text\">a</code> could be obtained by declaring a new type inverting <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code>, much like in the previous section. So we finally got our result: <code class=\"language-text\">Pair</code> is functorial in <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code>, and we have an explicit way of building the underlying functors from the basic functors <code class=\"language-text\">Const ()</code> and <code class=\"language-text\">Indentity</code>. </p>\n<p>We can easily convince ourselves that this result holds any other sum / product of basic types. For example, let’s consider the <code class=\"language-text\">Maybe</code> type:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">data Maybe a\n  = Nothing\n  | Just a</code></pre></div>\n<p>In this case it’s even easier since we have only one type parameter. We can build an isomorphic type out of the sum (<code class=\"language-text\">Either</code>) of <code class=\"language-text\">Const ()</code> and <code class=\"language-text\">Identity</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type Maybe&#39; a = BiComp Either (Const ()) Identity () a</code></pre></div>\n<p>The corresponding isomorphisms from <code class=\"language-text\">Maybe</code> to <code class=\"language-text\">Maybe&#39;</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">isoMaybe&#39; :: Maybe a -&gt; Maybe&#39; a\nisoMaybe&#39; Nothing = BiComp (Left $ Const ())\nisoMaybe&#39; (Just x) = BiComp (Right (Identity x))\n\nisoMaybe :: Maybe&#39; a -&gt; Maybe a\nisoMaybe (BiComp (Left _)) = Nothing\nisoMaybe (BiComp (Right (Identity x))) = Just x</code></pre></div>\n<p>And the following <code class=\"language-text\">Functor</code> instance:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">instance Functor Maybe where\n  fmap f = isoMaybe . second f . isoMaybe&#39;</code></pre></div>\n<h1>Conclusion</h1>\n<p>This post turned out to be much longer than expected, and frankly speaking, quite annoying to write. But it definitely deepened my understanding of functor derivation in Haskell, and I hope it’s the same for you! You can find a gist containing the code <a href=\"https://gist.github.com/vincent-prz/ec1837ce0361b748ddb1cd0911fadb6c\">here</a>.</p>","frontmatter":{"title":"Understanding Haskell functor derivation with Category Theory","date":"November 21, 2019","description":"Understanding functor derivation with Category Theory"}},"previous":{"fields":{"slug":"/rc-checkpoint/"},"frontmatter":{"title":"RC - 4 weeks checkpoint"}},"next":{"fields":{"slug":"/lambda-calculus/"},"frontmatter":{"title":"Creating a lambda calculus interpreter - report"}}},"pageContext":{"id":"9a3fb52a-addb-5b64-ab97-b3cf92c3301d","previousPostId":"d4ce3d82-025b-53f1-9dc4-9f689444b624","nextPostId":"0f2ce05d-1a8b-5e55-beb4-949cf83f3260"}},"staticQueryHashes":["2841359383","3257411868"]}